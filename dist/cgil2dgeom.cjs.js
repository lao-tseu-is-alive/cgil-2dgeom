module.exports=function(e){function t(r){if(n[r])return n[r].exports;var i=n[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,t),i.l=!0,i.exports}var n={};return t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:r})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="/",t(t.s=2)}([function(e,t,n){"use strict";function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}var i=n(1),o=function(){function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}}(),a=function(){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;r(this,e),"number"==typeof t[0]&&"number"==typeof t[1]?(this.x=t[0],this.y=t[1]):(this.x=t,this.y=n)}return o(e,[{key:"toString",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:",",t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:2;return t?"("+Object(i.roundNumber)(this.x,n)+e+" "+Object(i.roundNumber)(this.y,2)+")":""+Object(i.roundNumber)(this.x,n)+e+" "+Object(i.roundNumber)(this.y,2)}},{key:"toArray",value:function(){return[this.x,this.y]}},{key:"toWKT",value:function(){return"POINT("+this.x+" "+this.y+")"}},{key:"toEWKT",value:function(){return"SRID="+(arguments.length>0&&void 0!==arguments[0]?arguments[0]:21781)+";POINT("+this.x+" "+this.y+")"}},{key:"toGeoJSON",value:function(){return'{"type":"Point","coordinates":['+this.x+","+this.y+"]}"}},{key:"moveToArray",value:function(e){if(Object(i.isNumeric)(e[0])&&Object(i.isNumeric)(e[1]))return this.x=e[0],this.y=e[1],this;throw new TypeError("moveToArray needs an array of 2 numbers like this [1.0, 2.0]")}},{key:"moveTo",value:function(e,t){if(Object(i.isNumeric)(e)&&Object(i.isNumeric)(t))return this.x=e,this.y=t,this;throw new TypeError("moveTo needs newX and newY to be valid numbers !")}},{key:"moveRelArray",value:function(e){if(Object(i.isNumeric)(e[0])&&Object(i.isNumeric)(e[1]))return this.x=this.x+e[0],this.y=this.y+e[1],this;throw new TypeError("moveRelArray needs an array of 2 numbers like this [1.0, 2.0]")}},{key:"moveRel",value:function(e,t){if(Object(i.isNumeric)(e)&&Object(i.isNumeric)(t))return this.x=this.x+e,this.y=this.y+t,this;throw new TypeError("moveRel needs deltaX and deltaY to be valid numbers !")}},{key:"moveRelPolar",value:function(t,n){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:i.AngularSystem.DEGREE,o=e.fromPolar(t,n,r);return this.x=this.x+o.x,this.y=this.y+o.y,this}},{key:"copyRelArray",value:function(t){if(Object(i.isNumeric)(t[0])&&Object(i.isNumeric)(t[1])){var n=e.fromPoint(this);return n.x=n.x+t[0],n.y=n.y+t[1],n}throw new TypeError("copyRelArray needs an array of 2 numbers like this [1.0, 2.0]")}},{key:"copyRel",value:function(t,n){if(Object(i.isNumeric)(t)&&Object(i.isNumeric)(n)){var r=e.fromPoint(this);return r.x=r.x+t,r.y=r.y+n,r}throw new TypeError("copyRel needs deltaX and deltaY to be valid numbers !")}},{key:"copyRelPolar",value:function(t,n){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:i.AngularSystem.DEGREE,o=e.fromPolar(t,n,r),a=e.fromPoint(this);return a.x=a.x+o.x,a.y=a.y+o.y,a}},{key:"equal",value:function(t){if(t instanceof e)return Math.abs(this.x-t.x)<=i.EPSILON&&Math.abs(this.y-t.y)<=i.EPSILON;throw new TypeError("A Point can only be compared to another Point")}},{key:"distance",value:function(t){if(t instanceof e){var n=Math.sqrt((this.x-t.x)*(this.x-t.x)+(this.y-t.y)*(this.y-t.y));return n<=i.EPSILON?0:n}throw new TypeError("Point.distance(otherPoint) expects a Point as parameter")}},{key:"x",get:function(){return this._x},set:function(e){if(!Object(i.isNumeric)(e))throw this._x=NaN,this.isInvalid=!0,this.InvalidReason="cannot set x to "+e+" because it is not a numeric value",new TypeError("Point.x setter needs a numeric value and "+e+" is not");this._x=parseFloat(e)}},{key:"y",get:function(){return this._y},set:function(e){if(!Object(i.isNumeric)(e))throw this._y=NaN,this.isInvalid=!0,this.InvalidReason="cannot set y to "+e+" because it is not a numeric value",new TypeError("Point.y setter needs a numeric value and "+e+" is not");this._y=parseFloat(e)}}],[{key:"fromPolar",value:function(t,n){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:i.AngularSystem.DEGREE;if(Object(i.isNumeric)(t)&&Object(i.isNumeric)(n)){var o=0;o=r===i.AngularSystem.RADIAN?n:Object(i.getRadians)(n);var a=new e;a._radius=t,a._theta=o;var s=t*Math.cos(o);a.x=Math.abs(s)<=i.EPSILON?0:Object(i.roundNumber)(s,i.PRECISION);var u=t*Math.sin(o);return a.y=Math.abs(u)<=i.EPSILON?0:Object(i.roundNumber)(u,i.PRECISION),a}throw new TypeError("fromPolar needs radius and theta to be valid numbers !")}},{key:"fromPoint",value:function(t){if(t instanceof e)return new e(t.x,t.y);throw new TypeError("fromPoint needs parameter otherPoint of type Point")}},{key:"ccw",value:function(t,n,r){if(t instanceof e&&n instanceof e&&r instanceof e){var o={counterClockwise:null,allPointsAreColinear:null,value:null},a=n.x-t.x,s=r.x-t.x,u=n.y-t.y,c=r.y-t.y;if(console.log("### IN Point.ccw(P0 = "+t.toString()+", P1 = "+n.toString()+", P2 = "+r.toString()+")"),console.log("dx1 = "+a+", dx2 = "+s+", dy1 = "+u+", dy2 = "+c),Math.abs(a)<=i.EPSILON&&Math.abs(u)<=i.EPSILON)throw console.log("ERROR ==> P0 and P1 are identical !"),new Error("PointCcwPointIdenticalException ==> P0 and P1 are identical");if(Math.abs(s)<=i.EPSILON&&Math.abs(c)<=i.EPSILON)throw console.log("ERROR ==> P0 and P2 are identical !"),new Error("PointCcwPointIdenticalException ==> P0 and P2 are identical");if(n.equal(r))throw console.log("ERROR ==> P1 and P2 are identical !"),new Error("PointCcwPointIdenticalException ==> P1 and P2 are identical");var l=a*c,d=u*s;return console.log("Cpa = (dx1 * dy2) = "+l+", CPb = dy1 * dx2 = "+d),Math.abs(l-d)<=i.EPSILON?(console.log("==> ALL 3 POINTS ARE COLINEAR because = (Cpa - CPb) <= EPSILON "),o.allPointsAreColinear=!0,a*s<0||u*c<0?(o.counterClockwise=!1,o.value=-1,console.log("==> And P0 is between P1->P2")):a*a+u*u<s*s+c*c?(o.counterClockwise=!0,o.value=1,console.log("==> And P1 is between P0->P2")):(o.counterClockwise=!1,o.value=0,console.log("==> And P2 is between P0->P1"))):(o.allPointsAreColinear=!1,l>d?(o.counterClockwise=!0,o.value=1,console.log("=> From P0->P1->P2 we turn counter-clockwise")):(o.counterClockwise=!1,o.value=-1,console.log("=> From P0->P1->P2 we turn clockwise"))),o}throw console.log("ERROR ==> P0,P1 and P2 SHOULD be of type Point class !"),new TypeError("Point.ccw(P0, P1, P2) expects all parameters to be from Point class")}}]),e}();t.a=a},function(e,t,n){"use strict";function r(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:o,n=(e+"e").split("e");return n=(Math.round(Number(n[0]+"e"+(+n[1]+t)))+"e").split("e"),Number(n[0]+"e"+(+n[1]-t))}Object.defineProperty(t,"__esModule",{value:!0}),n.d(t,"isNumeric",function(){return i}),n.d(t,"PRECISION",function(){return o}),n.d(t,"EPSILON",function(){return a}),n.d(t,"DIGITIZE_PRECISION",function(){return s}),n.d(t,"AngularSystem",function(){return u}),n.d(t,"getRadians",function(){return c}),n.d(t,"getDegrees",function(){return l}),n.d(t,"getGradians",function(){return d}),t.roundNumber=r,n.d(t,"fixDec",function(){return f});var i=function(e){return!isNaN(parseFloat(e))&&isFinite(e)},o=10,a=Number("1e-"+o),s=2,u=Object.freeze({RADIAN:{id:0,max:2*Math.PI},DEGREE:{id:1,max:360},GRADIAN:{id:2,max:400}}),c=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:u.DEGREE;return e*(u.RADIAN.max/t.max)},l=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:u.RADIAN;return e*(u.DEGREE.max/t.max)},d=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:u.DEGREE;return e*(u.GRADIAN.max/t.max)},f=function(e){return parseFloat(Number(e).toFixed(s))}},function(e,t,n){e.exports=n(3)},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),n.d(t,"__VERSION__",function(){return s});var r=n(0),i=n(4),o=n(1),a=n(5);n.n(a);n.d(t,"Point",function(){return r.a}),n.d(t,"Line",function(){return i.a}),n.d(t,"utils",function(){return o});var s=a.version},function(e,t,n){"use strict";function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}var i=n(0),o=function(){function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}}(),a={stroke:"#E1E1E1",strokeWidth:2},s=function(){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new i.a,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new i.a(1,1),o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;r(this,e),this._options=Object.assign({},a,o),this.startPoint=t,this.endPoint=n}return o(e,[{key:"toString",value:function(){return"Line("+this.startPoint.toString()+" -> "+this.endPoint.toString()+")"}},{key:"startPoint",get:function(){return this._startPoint},set:function(e){if(!(e instanceof i.a))throw new TypeError("startPoint setter needs parameter otherPoint of type Point");if(e.isInvalid)throw new TypeError("Class Line needs a valid startPoint : "+e.InvalidReason);if(void 0!==this._endPoint&&e.equal(this._endPoint))throw new TypeError("Class Line needs a startPoint different from endPoint : "+e.toString()+" == "+this._endPoint.toString());this._startPoint=i.a.fromPoint(e)}},{key:"endPoint",get:function(){return this._endPoint},set:function(e){if(!(e instanceof i.a))throw new TypeError("endPoint setter needs parameter otherPoint of type Point");if(e.isInvalid)throw new TypeError("Class Line needs a valid endPoint : "+e.InvalidReason);if(void 0!==this._startPoint&&e.equal(this._startPoint))throw new TypeError("Class Line needs a endPoint different from startPoint: "+e.toString()+" == "+this._startPoint.toString());this._endPoint=i.a.fromPoint(e)}}]),e}();t.a=s},function(e,t){e.exports={name:"cgil-2dgeom",version:"1.0.0",description:"2d geometry utility classes",main:"dist/index.js",scripts:{dev:"poi","build:CJS":"poi build -c poi.config-CommonJS.js ","build:UMD":"poi build -c poi.config-umd.js ",lint:"eslint src/*.js",test:"tyu -- --watch ","test-ci-travis":"jest -i",jest:"jest"},repository:{type:"git",url:"git+https://github.com/lao-tseu-is-alive/cgil-2dgeom.git"},keywords:["2d","geometry","class","point","line","circle"],author:"cgil <lao.tseu.is.alive@gmail.com>",license:"MIT",bugs:{url:"https://github.com/lao-tseu-is-alive/cgil-2dgeom/issues"},homepage:"https://github.com/lao-tseu-is-alive/cgil-2dgeom#readme",jest:{verbose:!0,coverageDirectory:"./coverage/",collectCoverage:!0,collectCoverageFrom:["**/src/*.{js,jsx}","!**/node_modules/**","!**/vendor/**"]},devDependencies:{"babel-core":"^6.26.0","babel-eslint":"^8.2.2","babel-jest":"^22.4.1",eslint:"^4.19.1","eslint-config-standard":"^11.0.0","eslint-config-xo":"^0.20.1","eslint-import-resolver-webpack":"^0.9.0","eslint-plugin-import":"^2.10.0","eslint-plugin-standard":"^3.0.1",jest:"^22.4.2",poi:"^9.6.13","regenerator-runtime":"^0.11.1",tyu:"^1.0.5",xo:"^0.20.3"}}}]);