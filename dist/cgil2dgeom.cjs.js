module.exports=function(e){function t(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,t),o.l=!0,o.exports}var n={};return t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:r})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="/",t(t.s=1)}([function(e,t,n){"use strict";function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var o=n(3),i=function(){function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}}(),a=function(){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;r(this,e),"number"==typeof t[0]&&"number"==typeof t[1]?(this.x=t[0],this.y=t[1]):(this.x=t,this.y=n)}return i(e,[{key:"toString",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:",";return"("+this.x+e+" "+this.y+")"}},{key:"toArray",value:function(){return[this.x,this.y]}},{key:"toWKT",value:function(){return"POINT("+this.x+" "+this.y+")"}},{key:"toEWKT",value:function(){return"SRID="+(arguments.length>0&&void 0!==arguments[0]?arguments[0]:21781)+";POINT("+this.x+" "+this.y+")"}},{key:"toGeoJSON",value:function(){return'{"type":"Point","coordinates":['+this.x+","+this.y+"]}"}},{key:"moveToArray",value:function(e){if(Object(o.e)(e[0])&&Object(o.e)(e[1]))return this.x=e[0],this.y=e[1],this;throw new TypeError("moveToArray needs an array of 2 numbers like this [1.0, 2.0]")}},{key:"moveTo",value:function(e,t){if(Object(o.e)(e)&&Object(o.e)(t))return this.x=e,this.y=t,this;throw new TypeError("moveTo needs newX and newY to be valid numbers !")}},{key:"moveRelArray",value:function(e){if(Object(o.e)(e[0])&&Object(o.e)(e[1]))return this.x=this.x+e[0],this.y=this.y+e[1],this;throw new TypeError("moveRelArray needs an array of 2 numbers like this [1.0, 2.0]")}},{key:"moveRel",value:function(e,t){if(Object(o.e)(e)&&Object(o.e)(t))return this.x=this.x+e,this.y=this.y+t,this;throw new TypeError("moveRel needs deltaX and deltaY to be valid numbers !")}},{key:"moveRelPolar",value:function(t,n){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:o.a.DEGREE,i=e.fromPolar(t,n,r);return this.x=this.x+i.x,this.y=this.y+i.y,this}},{key:"copyRelArray",value:function(t){if(Object(o.e)(t[0])&&Object(o.e)(t[1])){var n=e.fromPoint(this);return n.x=n.x+t[0],n.y=n.y+t[1],n}throw new TypeError("copyRelArray needs an array of 2 numbers like this [1.0, 2.0]")}},{key:"copyRel",value:function(t,n){if(Object(o.e)(t)&&Object(o.e)(n)){var r=e.fromPoint(this);return r.x=r.x+t,r.y=r.y+n,r}throw new TypeError("copyRel needs deltaX and deltaY to be valid numbers !")}},{key:"copyRelPolar",value:function(t,n){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:o.a.DEGREE,i=e.fromPolar(t,n,r),a=e.fromPoint(this);return a.x=a.x+i.x,a.y=a.y+i.y,a}},{key:"equal",value:function(t){if(t instanceof e)return Math.abs(this.x-t.x)<=o.b&&Math.abs(this.y-t.y)<=o.b;throw new TypeError("A Point can only be compared to another Point")}},{key:"distance",value:function(t){if(t instanceof e){var n=Math.sqrt((this.x-t.x)*(this.x-t.x)+(this.y-t.y)*(this.y-t.y));return n<=o.b?0:n}throw new TypeError("Point.distance(otherPoint) expects a Point as parameter")}},{key:"x",get:function(){return this._x},set:function(e){if(!Object(o.e)(e))throw this._x=NaN,this.isInvalid=!0,this.InvalidReason="cannot set x to "+e+" because it is not a numeric value",new TypeError("Point.x setter needs a numeric value and "+e+" is not");this._x=parseFloat(e)}},{key:"y",get:function(){return this._y},set:function(e){if(!Object(o.e)(e))throw this._y=NaN,this.isInvalid=!0,this.InvalidReason="cannot set y to "+e+" because it is not a numeric value",new TypeError("Point.y setter needs a numeric value and "+e+" is not");this._y=parseFloat(e)}}],[{key:"fromPolar",value:function(t,n){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:o.a.DEGREE;if(Object(o.e)(t)&&Object(o.e)(n)){var i=0;i=r===o.a.RADIAN?n:Object(o.d)(n);var a=new e;a._radius=t,a._theta=i;var s=t*Math.cos(i);a.x=Math.abs(s)<=o.b?0:Object(o.f)(s,o.c);var u=t*Math.sin(i);return a.y=Math.abs(u)<=o.b?0:Object(o.f)(u,o.c),a}throw new TypeError("fromPolar needs radius and theta to be valid numbers !")}},{key:"fromPoint",value:function(t){if(t instanceof e)return new e(t.x,t.y);throw new TypeError("fromPoint needs parameter otherPoint of type Point")}},{key:"ccw",value:function(t,n,r){if(t instanceof e&&n instanceof e&&r instanceof e){var i={counterClockwise:null,allPointsAreColinear:null,value:null},a=n.x-t.x,s=r.x-t.x,u=n.y-t.y,l=r.y-t.y;if(console.log("### IN Point.ccw(P0 = "+t.toString()+", P1 = "+n.toString()+", P2 = "+r.toString()+")"),console.log("dx1 = "+a+", dx2 = "+s+", dy1 = "+u+", dy2 = "+l),Math.abs(a)<=o.b&&Math.abs(u)<=o.b)throw console.log("ERROR ==> P0 and P1 are identical !"),new Error("PointCcwPointIdenticalException ==> P0 and P1 are identical");if(Math.abs(s)<=o.b&&Math.abs(l)<=o.b)throw console.log("ERROR ==> P0 and P2 are identical !"),new Error("PointCcwPointIdenticalException ==> P0 and P2 are identical");if(n.equal(r))throw console.log("ERROR ==> P1 and P2 are identical !"),new Error("PointCcwPointIdenticalException ==> P1 and P2 are identical");var c=a*l,f=u*s;return console.log("Cpa = (dx1 * dy2) = "+c+", CPb = dy1 * dx2 = "+f),Math.abs(c-f)<=o.b?(console.log("==> ALL 3 POINTS ARE COLINEAR because = (Cpa - CPb) <= EPSILON "),i.allPointsAreColinear=!0,a*s<0||u*l<0?(i.counterClockwise=!1,i.value=-1,console.log("==> And P0 is between P1->P2")):a*a+u*u<s*s+l*l?(i.counterClockwise=!0,i.value=1,console.log("==> And P1 is between P0->P2")):(i.counterClockwise=!1,i.value=0,console.log("==> And P2 is between P0->P1"))):(i.allPointsAreColinear=!1,c>f?(i.counterClockwise=!0,i.value=1,console.log("=> From P0->P1->P2 we turn counter-clockwise")):(i.counterClockwise=!1,i.value=-1,console.log("=> From P0->P1->P2 we turn clockwise"))),i}throw console.log("ERROR ==> P0,P1 and P2 SHOULD be of type Point class !"),new TypeError("Point.ccw(P0, P1, P2) expects all parameters to be from Point class")}}]),e}();t.default=a},function(e,t,n){e.exports=n(2)},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var r=n(0),o=n(4);n.d(t,"Point",function(){return r}),n.d(t,"Line",function(){return o})},function(e,t,n){"use strict";function r(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:i,n=(e+"e").split("e");return n=(Math.round(Number(n[0]+"e"+(+n[1]+t)))+"e").split("e"),Number(n[0]+"e"+(+n[1]-t))}n.d(t,"e",function(){return o}),n.d(t,"c",function(){return i}),n.d(t,"b",function(){return a}),n.d(t,"a",function(){return s}),n.d(t,"d",function(){return u}),t.f=r;var o=function(e){return!isNaN(parseFloat(e))&&isFinite(e)},i=10,a=Number("1e-"+i),s=Object.freeze({RADIAN:{id:0,max:2*Math.PI},DEGREE:{id:1,max:360},GRADIAN:{id:2,max:400}}),u=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:s.DEGREE;return e*(s.RADIAN.max/t.max)}},function(e,t,n){"use strict";function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var o=n(0),i=function(){function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}}(),a={stroke:"#E1E1E1",strokeWidth:2},s=function(){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new o.default,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new o.default(1,1),i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(r(this,e),this._options=Object.assign({},a,i),this.startPoint=t,this.endPoint=n,n.equal(t))throw new TypeError("Class Line needs a endPoint different from startPoint: "+n.toString()+" == "+t.toString())}return i(e,[{key:"toString",value:function(){return"Line("+this.startPoint.toString()+" -> "+this.endPoint.toString()+")"}},{key:"startPoint",get:function(){return this._startPoint},set:function(e){if(!(e instanceof o.default))throw new TypeError("startPoint setter needs parameter otherPoint of type Point");if(e.isInvalid)throw new TypeError("Class Line needs a valid startPoint : "+e.InvalidReason);if(void 0!==this._endPoint&&e.equal(this._endPoint))throw new TypeError("Class Line needs a startPoint different from endPoint : "+e.toString()+" == "+this._endPoint.toString());this._startPoint=o.default.fromPoint(e)}},{key:"endPoint",get:function(){return this._endPoint},set:function(e){if(!(e instanceof o.default))throw new TypeError("endPoint setter needs parameter otherPoint of type Point");if(e.isInvalid)throw new TypeError("Class Line needs a valid endPoint : "+e.InvalidReason);if(void 0!==this._startPoint&&e.equal(this._startPoint))throw new TypeError("Class Line needs a endPoint different from startPoint: "+e.toString()+" == "+this._startPoint.toString());this._endPoint=o.default.fromPoint(e)}}]),e}();t.default=s}]);