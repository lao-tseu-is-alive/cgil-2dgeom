(function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.geom2d=t():e.geom2d=t()})("undefined"!=typeof self?self:this,function(){return function(e){function t(i){if(n[i])return n[i].exports;var r=n[i]={i:i,l:!1,exports:{}};return e[i].call(r.exports,r,r.exports,t),r.l=!0,r.exports}var n={};return t.m=e,t.c=n,t.d=function(e,n,i){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:i})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="/",t(t.s=2)}([function(e,t,n){"use strict";function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}var r=n(1),o=function(){function e(e,t){for(var n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}return function(t,n,i){return n&&e(t.prototype,n),i&&e(t,i),t}}(),s=function(){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;i(this,e),"number"==typeof t[0]&&"number"==typeof t[1]?(this.x=t[0],this.y=t[1]):(this.x=t,this.y=n)}return o(e,[{key:"toString",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:",",t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:2;return t?"("+Object(r.roundNumber)(this.x,n)+e+" "+Object(r.roundNumber)(this.y,2)+")":""+Object(r.roundNumber)(this.x,n)+e+" "+Object(r.roundNumber)(this.y,2)}},{key:"toArray",value:function(){return[this.x,this.y]}},{key:"toWKT",value:function(){return"POINT("+this.x+" "+this.y+")"}},{key:"toEWKT",value:function(){return"SRID="+(arguments.length>0&&void 0!==arguments[0]?arguments[0]:21781)+";POINT("+this.x+" "+this.y+")"}},{key:"toGeoJSON",value:function(){return'{"type":"Point","coordinates":['+this.x+","+this.y+"]}"}},{key:"moveToArray",value:function(e){if(Object(r.isNumeric)(e[0])&&Object(r.isNumeric)(e[1]))return this.x=e[0],this.y=e[1],this;throw new TypeError("moveToArray needs an array of 2 numbers like this [1.0, 2.0]")}},{key:"moveTo",value:function(e,t){if(Object(r.isNumeric)(e)&&Object(r.isNumeric)(t))return this.x=e,this.y=t,this;throw new TypeError("moveTo needs newX and newY to be valid numbers !")}},{key:"moveRelArray",value:function(e){if(Object(r.isNumeric)(e[0])&&Object(r.isNumeric)(e[1]))return this.x=this.x+e[0],this.y=this.y+e[1],this;throw new TypeError("moveRelArray needs an array of 2 numbers like this [1.0, 2.0]")}},{key:"moveRel",value:function(e,t){if(Object(r.isNumeric)(e)&&Object(r.isNumeric)(t))return this.x=this.x+e,this.y=this.y+t,this;throw new TypeError("moveRel needs deltaX and deltaY to be valid numbers !")}},{key:"moveRelPolar",value:function(t,n){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:r.AngularSystem.DEGREE,o=e.fromPolar(t,n,i);return this.x=this.x+o.x,this.y=this.y+o.y,this}},{key:"copyRelArray",value:function(t){if(Object(r.isNumeric)(t[0])&&Object(r.isNumeric)(t[1])){var n=e.fromPoint(this);return n.x=n.x+t[0],n.y=n.y+t[1],n}throw new TypeError("copyRelArray needs an array of 2 numbers like this [1.0, 2.0]")}},{key:"copyRel",value:function(t,n){if(Object(r.isNumeric)(t)&&Object(r.isNumeric)(n)){var i=e.fromPoint(this);return i.x=i.x+t,i.y=i.y+n,i}throw new TypeError("copyRel needs deltaX and deltaY to be valid numbers !")}},{key:"copyRelPolar",value:function(t,n){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:r.AngularSystem.DEGREE,o=e.fromPolar(t,n,i),s=e.fromPoint(this);return s.x=s.x+o.x,s.y=s.y+o.y,s}},{key:"equal",value:function(t){if(t instanceof e)return Math.abs(this.x-t.x)<=r.EPSILON&&Math.abs(this.y-t.y)<=r.EPSILON;throw new TypeError("A Point can only be compared to another Point")}},{key:"distance",value:function(t){if(t instanceof e){var n=Math.sqrt((this.x-t.x)*(this.x-t.x)+(this.y-t.y)*(this.y-t.y));return n<=r.EPSILON?0:n}throw new TypeError("Point.distance(otherPoint) expects a Point as parameter")}},{key:"x",get:function(){return this._x},set:function(e){if(!Object(r.isNumeric)(e))throw this._x=NaN,this.isInvalid=!0,this.InvalidReason="cannot set x to "+e+" because it is not a numeric value",new TypeError("Point.x setter needs a numeric value and "+e+" is not");this._x=parseFloat(e)}},{key:"y",get:function(){return this._y},set:function(e){if(!Object(r.isNumeric)(e))throw this._y=NaN,this.isInvalid=!0,this.InvalidReason="cannot set y to "+e+" because it is not a numeric value",new TypeError("Point.y setter needs a numeric value and "+e+" is not");this._y=parseFloat(e)}}],[{key:"fromPolar",value:function(t,n){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:r.AngularSystem.DEGREE;if(Object(r.isNumeric)(t)&&Object(r.isNumeric)(n)){var o=0;o=i===r.AngularSystem.RADIAN?n:Object(r.getRadians)(n);var s=new e;s._radius=t,s._theta=o;var a=t*Math.cos(o);s.x=Math.abs(a)<=r.EPSILON?0:Object(r.roundNumber)(a,r.PRECISION);var u=t*Math.sin(o);return s.y=Math.abs(u)<=r.EPSILON?0:Object(r.roundNumber)(u,r.PRECISION),s}throw new TypeError("fromPolar needs radius and theta to be valid numbers !")}},{key:"fromPoint",value:function(t){if(t instanceof e)return new e(t.x,t.y);throw new TypeError("fromPoint needs parameter otherPoint of type Point")}},{key:"ccw",value:function(t,n,i){if(t instanceof e&&n instanceof e&&i instanceof e){var o={counterClockwise:null,allPointsAreColinear:null,value:null},s=n.x-t.x,a=i.x-t.x,u=n.y-t.y,c=i.y-t.y;if(console.log("### IN Point.ccw(P0 = "+t.toString()+", P1 = "+n.toString()+", P2 = "+i.toString()+")"),console.log("dx1 = "+s+", dx2 = "+a+", dy1 = "+u+", dy2 = "+c),Math.abs(s)<=r.EPSILON&&Math.abs(u)<=r.EPSILON)throw console.log("ERROR ==> P0 and P1 are identical !"),new Error("PointCcwPointIdenticalException ==> P0 and P1 are identical");if(Math.abs(a)<=r.EPSILON&&Math.abs(c)<=r.EPSILON)throw console.log("ERROR ==> P0 and P2 are identical !"),new Error("PointCcwPointIdenticalException ==> P0 and P2 are identical");if(n.equal(i))throw console.log("ERROR ==> P1 and P2 are identical !"),new Error("PointCcwPointIdenticalException ==> P1 and P2 are identical");var l=s*c,d=u*a;return console.log("Cpa = (dx1 * dy2) = "+l+", CPb = dy1 * dx2 = "+d),Math.abs(l-d)<=r.EPSILON?(console.log("==> ALL 3 POINTS ARE COLINEAR because = (Cpa - CPb) <= EPSILON "),o.allPointsAreColinear=!0,s*a<0||u*c<0?(o.counterClockwise=!1,o.value=-1,console.log("==> And P0 is between P1->P2")):s*s+u*u<a*a+c*c?(o.counterClockwise=!0,o.value=1,console.log("==> And P1 is between P0->P2")):(o.counterClockwise=!1,o.value=0,console.log("==> And P2 is between P0->P1"))):(o.allPointsAreColinear=!1,l>d?(o.counterClockwise=!0,o.value=1,console.log("=> From P0->P1->P2 we turn counter-clockwise")):(o.counterClockwise=!1,o.value=-1,console.log("=> From P0->P1->P2 we turn clockwise"))),o}throw console.log("ERROR ==> P0,P1 and P2 SHOULD be of type Point class !"),new TypeError("Point.ccw(P0, P1, P2) expects all parameters to be from Point class")}}]),e}();t.a=s},function(e,t,n){"use strict";function i(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:o,n=(e+"e").split("e");return n=(Math.round(Number(n[0]+"e"+(+n[1]+t)))+"e").split("e"),Number(n[0]+"e"+(+n[1]-t))}Object.defineProperty(t,"__esModule",{value:!0}),n.d(t,"isNumeric",function(){return r}),n.d(t,"PRECISION",function(){return o}),n.d(t,"EPSILON",function(){return s}),n.d(t,"DIGITIZE_PRECISION",function(){return a}),n.d(t,"AngularSystem",function(){return u}),n.d(t,"getRadians",function(){return c}),n.d(t,"getDegrees",function(){return l}),n.d(t,"getGradians",function(){return d}),t.roundNumber=i,n.d(t,"fixDec",function(){return f});var r=function(e){return!isNaN(parseFloat(e))&&isFinite(e)},o=10,s=Number("1e-"+o),a=2,u=Object.freeze({RADIAN:{id:0,max:2*Math.PI},DEGREE:{id:1,max:360},GRADIAN:{id:2,max:400}}),c=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:u.DEGREE;return e*(u.RADIAN.max/t.max)},l=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:u.RADIAN;return e*(u.DEGREE.max/t.max)},d=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:u.DEGREE;return e*(u.GRADIAN.max/t.max)},f=function(e){return parseFloat(Number(e).toFixed(a))}},function(e,t,n){e.exports=n(3)},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),n.d(t,"__VERSION__",function(){return a});var i=n(0),r=n(4),o=n(1),s=n(5);n.n(s);n.d(t,"Point",function(){return i.a}),n.d(t,"Line",function(){return r.a}),n.d(t,"utils",function(){return o});var a=s.version},function(e,t,n){"use strict";function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}var r=n(0),o=function(){function e(e,t){for(var n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}return function(t,n,i){return n&&e(t.prototype,n),i&&e(t,i),t}}(),s={stroke:"#E1E1E1",strokeWidth:2},a=function(){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new r.a,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new r.a(1,1),o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;i(this,e),this._options=Object.assign({},s,o),this.startPoint=t,this.endPoint=n}return o(e,[{key:"toString",value:function(){return"Line("+this.startPoint.toString()+" -> "+this.endPoint.toString()+")"}},{key:"startPoint",get:function(){return this._startPoint},set:function(e){if(!(e instanceof r.a))throw new TypeError("startPoint setter needs parameter otherPoint of type Point");if(e.isInvalid)throw new TypeError("Class Line needs a valid startPoint : "+e.InvalidReason);if(void 0!==this._endPoint&&e.equal(this._endPoint))throw new TypeError("Class Line needs a startPoint different from endPoint : "+e.toString()+" == "+this._endPoint.toString());this._startPoint=r.a.fromPoint(e)}},{key:"endPoint",get:function(){return this._endPoint},set:function(e){if(!(e instanceof r.a))throw new TypeError("endPoint setter needs parameter otherPoint of type Point");if(e.isInvalid)throw new TypeError("Class Line needs a valid endPoint : "+e.InvalidReason);if(void 0!==this._startPoint&&e.equal(this._startPoint))throw new TypeError("Class Line needs a endPoint different from startPoint: "+e.toString()+" == "+this._startPoint.toString());this._endPoint=r.a.fromPoint(e)}}]),e}();t.a=a},function(e,t){e.exports={name:"cgil-geom2d",version:"1.0.0",description:"2d geometry ES6 javascript classes like Point Lines with polar coordinates conversions..",main:"dist/geom2d.min.js",scripts:{dev:"poi","build:CJS":"poi build -c poi.config-CommonJS.js ","build:UMD":"poi build -c poi.config-umd.js ",lint:"eslint src/*.js",test:"tyu -- --watch ","test-ci-travis":"jest -i",jest:"jest"},repository:{type:"git",url:"https://github.com/lao-tseu-is-alive/cgil-2dgeom.git"},keywords:["2d","geometry","class","point","line","polar coordinates"],licenses:[{type:"MIT",url:"http://www.opensource.org/licenses/mit-license.php"}],author:"cgil <lao.tseu.is.alive@gmail.com>",license:"MIT",bugs:{url:"https://github.com/lao-tseu-is-alive/cgil-2dgeom/issues"},homepage:"https://github.com/lao-tseu-is-alive/cgil-2dgeom#readme",jest:{verbose:!0,coverageDirectory:"./coverage/",collectCoverage:!0,collectCoverageFrom:["**/src/*.{js,jsx}","!**/node_modules/**","!**/vendor/**"]},devDependencies:{"babel-core":"^6.26.0","babel-eslint":"^8.2.2","babel-jest":"^22.4.1",eslint:"^4.19.1","eslint-config-standard":"^11.0.0","eslint-config-xo":"^0.20.1","eslint-import-resolver-webpack":"^0.9.0","eslint-plugin-import":"^2.10.0","eslint-plugin-node":"^6.0.1","eslint-plugin-promise":"^3.7.0","eslint-plugin-standard":"^3.0.1",jest:"^22.4.2",poi:"^9.6.13","regenerator-runtime":"^0.11.1",tyu:"^1.0.5"}}}])});